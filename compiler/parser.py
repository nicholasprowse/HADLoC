from .tokenizer import Token
from error import CompilerException


class Parser:
    """
    Attributes:
        ast (ASTNode): The parent node of the abstract syntax tree generated from parsing the tokens
        index (int): The index of the token that is currently being parsed

    Args:
        tokens (list<tuple<str, CodeObject>>): A list of tokens generated by the tokenizer. Each element is a tuple
            consisting of the token type as a string, and the token value as a CodeObject
    """
    def __init__(self, tokens):
        self.ast = None
        self.index = 0
        self.tokens = tokens
        self.parse_program()

    def type(self, offset=0):
        """
        Returns the type of the token offset by a given amount from the token currently being parsed. If the requested
        token is out of bounds of the tokens array, then an empty string is returned

        Args:
            offset (int): the offset from the current token

        Returns:
             (str) the type of the token offset by a given amount from the token currently being parsed, or an
             empty string if the given offset is out of bounds
        """
        if self.index + offset >= len(self.tokens):
            return ''
        return self.tokens[self.index + offset][0]

    def value(self, offset=0):
        """
        Returns the value of the token offset by a given amount from the token currently being parsed. If the requested
        token is out of bounds of the tokens array, then None is returned

        Args:
            offset (int): the offset from the current token

        Returns:
             (CodeObject) the value of the token offset by a given amount from the token currently being parsed, or
             None if the given offset is out of bounds
        """
        if self.index + offset >= len(self.tokens):
            return None
        return self.tokens[self.index + offset][1]

    def match(self, value):
        """
        Simple helper function that returns True if the current tokens value matches the given argument. If the token
        matched, then it is advanced past, otherwise it is not, and False is returned
        """
        if self.value() == value:
            self.index += 1
            return True
        return False

    def parse_program(self):
        """
        Parses a program. A program is defined as follows
        Program         ::=  ImportDeclaration* ClassDeclaration*

        Creates a node with two children: Imports and Classes, both of which are lists of ASTNodes.

        Raises:
            CompilerException: if there is an error in the code to parse
        """
        self.ast = ASTNode('Program', {'Imports': [], 'Classes': []})
        while self.parse_importdeclaration(self.ast):
            pass

        while self.parse_classdeclaration(self.ast):
            pass

    def parse_importdeclaration(self, parent, name='Imports'):
        """
        An import declaration is defined as follows
        ImportDeclaration       ::=  'import' TypeName ';'

        Creates a node containing a single child. This child has a name of 'Name' and is a TypeName

        Args:
            parent (ASTNode): The node that is the parent of the node that this function will create. This function
                will add its node to this parent as a child
            name (str): The name with which this child should use when it adds itself to its parent

        Returns:
            True if an import declaration was successfully parsed. False otherwise
        """
        if not self.match('import'):
            return False
        node = ASTNode('ImportDeclaration')
        if not self.parse_typename(node, 'Name'):
            raise CompilerException(CompilerException.SYNTAX, 'Expected type name after import keyword',
                                    self.value(-1), offset=2)
        if not self.match(';'):
            raise CompilerException(CompilerException.SYNTAX, "Expected ';' after import declaration",
                                    self.value(-1), offset=1)
        parent.addchild(name, node)
        return True

    def parse_classdeclaration(self, parent):
        return False

    def parse_typename(self, parent, name='TypeName'):
        """
        Parses a type name. A type name is a sequence of identifiers, seperated with dots:
        TypeName        ::=  (Identifier '.')* Identifier

        Creates a node with a single type of child. The children have a name of 'Names' and this is a list of
        CodeObjects, where each one is an identifier in the sequence of names

        Args:
            parent (ASTNode): The node that is the parent of the node that this function will create. This function
                will add its node to this parent as a child
            name (str): The name with which this child should use when it adds itself to its parent

        Returns:
            True if an import declaration was successfully parsed. False otherwise
        """
        if self.type() is not Token.identifier:
            return False

        node = ASTNode('TypeName', {'Names': [self.value()]})
        self.index += 1
        while self.match('.'):
            if self.type() is Token.identifier:
                node.addchild('Names', self.value())
                self.index += 1
            else:
                raise CompilerException(CompilerException.SYNTAX,
                                        'Missing identifier after dot in type name', self.value(-1), offset=1)
        parent.addchild(name, node)
        return True


class ASTNode:
    """
    Represents a single node in an abstract syntax tree. Each node has a name (e.g. class declaration) and a dictionary
    of its children. Each child is an ASTNode. The keys of the children dictionary are the names of each child node,
    and the values are can be one of three things:
        - A token generated in the tokenizer. This is when the child is a terminal value (has no children of it own)
            A token is a tuple, consisting of the type (str) and the value (CodeObject)
        - An ASTNode. This is used when the child has its own children
        - A list of ASTNode objects or tokens. The list must consist of one or the other (not both). This is used when
            it is not known how many children of a certain type a node will have. For example, a parameter list will
            have an arbitrary number of ASTNode children, one for each parameter
    For example, a class declaraction node may have the following children:
        'privacy modifier', 'name', 'variable declarations', 'method declarations'
    where 'privacy modifier' and 'name' both consist of a token, and 'variable declarations',
    'method declarations' would both be lists of ASTNodes, since we cannot know how many variables/methods a class will
    have

    Attributes:
        name (str): the name/type of the ASTNode
        children (dict) dictionary containing all the children of the node
    """
    def __init__(self, name, children=None):
        self.name = name
        if children is None:
            self.children = {}
        else:
            self.children = children

    def addchild(self, name, child):
        """
        Adds the child to the children dictionary at the location given by name. If multiple children are added to the
        same name, then they will all be stored in a list. If a given item must be a list, even if it may have zero or
        one elements, then add an emtpy list before adding any children under that name
        """
        if name in self.children:
            if type(self[name]) == list:
                self[name].append(child)
            else:
                self[name] = [self[name], child]
        else:
            self[name] = child

    def __setitem__(self, name, child):
        """
        Sets the child with the given name to the given value.
        Note: This will overwrite any child already existing under that name. To add a child without the risk of
        overwriting a child use addchild(name, child)
        """
        self.children[name] = child

    def __getitem__(self, item):
        """This is used to access the children of the ASTNode"""
        return self.children[item]

    def print_tree(self, depth=0):
        """
        Prints this node, along will all child nodes, in a heirarcical manner
        Args:
            depth: This is the depth of this node from the root of the tree. This determines how far to indent this
                node
        """
        if depth == 0:
            print(self.name)
        prefix = '|   '*depth + '|-> '
        for name, child in self.children.items():
            print(prefix + name)
            if type(child) is list:
                for item in child:
                    if type(item) is ASTNode:
                        item.print_tree(depth+1)
                    else:
                        print('|   ' + prefix + str(item))
            elif type(child) is ASTNode:
                child.print_tree(depth+1)
            else:
                print('|   ' + prefix + str(child))
