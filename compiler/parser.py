from .tokenizer import Token
from error import CompilerException


class Parser:
    """
    Parses a J code file, given the list of tokens from the file. These tokens are generated using the tokenizer.
    The parser generates an abstract syntax tree using ASTNode objects to represent the structure of the code.
    This is done using a series of functions, each parses a single grammatical element. For example, the function
    class_declaration parses a class declaration and returns the ASTNode it generated. To parse a given element, the
    appropriate function should be passed into the parse function. This deals with adding the node to the tree, and
    resets the index if the parsing fails. The one exception to this is the parse_program function. This should be
    classed directly, and will return the root of the generated abstract syntax tree, as an ASTNode

    Attributes:
        ast (ASTNode): The parent node of the abstract syntax tree generated from parsing the tokens
        index (int): The index of the token that is currently being parsed
        tokens (tuple<Token, CodeObject>): List of tokens generated from the tokenizer

    Args:
        tokens (list<tuple<str, CodeObject>>): A list of tokens generated by the tokenizer. Each element is a tuple
            consisting of the token type as a string, and the token value as a CodeObject
    """

    def __init__(self, tokens):
        self.index = 0
        self.tokens = tokens
        self.ast = self.parse_program()

    def type(self, offset=0):
        """
        Returns the type of the token offset by a given amount from the token currently being parsed. If the requested
        token is out of bounds of the tokens array, then an empty string is returned

        Args:
            offset (int): the offset from the current token

        Returns:
             (str) the type of the token offset by a given amount from the token currently being parsed, or an
             empty string if the given offset is out of bounds
        """
        if self.index + offset >= len(self.tokens):
            return ''
        return self.tokens[self.index + offset][0]

    def raise_error(self, err_type, err_msg, offset=0, missing_msg=None):
        """
        Raises an error with a given type, message and location. Handles the case where the error location is a None
        token (doesn't exist) by using the token beforehand. An optional error message can be supplied for when this
        occurs, allowing for messages to behave differently depending on of a token is missing, or just wrong.

        Args:
            err_type (int): The type of the error message
            err_msg (str): Error message to display to the user
            offset (int): The offset from the current token, to the token that caused the error. This determines the
                token that the error message will highlight as having caused the error. This is optional and defaults to
                0 (the current token)
            missing_msg (str): Optional error message to display if the requested token (specified by offset) is None.
                If this is not supplied, it defaults to the message supplied by err_msg, meaning all errors show the
                same message
        Raises: Always raises a CompilerException
        """
        if missing_msg is None:
            missing_msg = err_msg
        if self.value(offset) is None:
            raise CompilerException(err_type, missing_msg, self.value(offset - 1))
        else:
            raise CompilerException(err_type, err_msg, self.value(offset))

    def value(self, offset=0):
        """
        Returns the value of the token offset by a given amount from the token currently being parsed. If the requested
        token is out of bounds of the tokens array, then None is returned

        Args:
            offset (int): the offset from the current token

        Returns:
             (CodeObject) the value of the token offset by a given amount from the token currently being parsed, or
             None if the given offset is out of bounds
        """
        if self.index + offset >= len(self.tokens):
            return None
        return self.tokens[self.index + offset][1]

    def match(self, value):
        """
        Simple helper function that returns True if the current tokens value matches the given argument. If the token
        matched, then it is advanced past, otherwise it is not, and False is returned
        """
        if self.value() == value:
            self.index += 1
            return True
        return False

    def parse_program(self):
        """
        Parses a program. A program is defined as follows
        Program         ::=  ImportDeclaration* ClassDeclaration*

        Creates a node with two children: Imports and Classes, both of which are lists of ASTNodes.

        Raises:
            CompilerException: if there is an error in the code to parse
        """
        node = ASTNode('Program', {'Imports': [], 'Classes': []})

        while self.parse(self.import_declaration, node, 'Imports'):
            pass

        while self.parse(self.class_declaration, node, 'Classes'):
            pass

        if self.index != len(self.tokens):
            raise CompilerException(CompilerException.SYNTAX, "Unexpected token", self.value())

        return node

    def parse(self, function, parent, name=None):
        """
        Calls the provided function. Before calling the function, saves the value of self.index. If the function returns
        None, then the value of self.index is restored, and False is returned. If a node is returned, then it is added
        to the abstract syntax tree with the given parent, under the given name. All parsing should be done by passing
        the function that parses an element into this function, as it automatically deals with restoring the value of
        self.index if parsing fails, and automatically deals with adding the node to the tree.

        Args:
            function (function): A function that parses the required grammar element. This function must return the
                ASTNode representing the grammar it parsed if its parsing was successful. If parsing is unsuccessful,
                this function should return None. In this case, the function does not need to restore the value of the
                index, as this function deals with that. Can raise a CompilerException if the code is found to contain
                errors
            parent (ASTNode): The node that is the parent of the node that this function will create. This function
                will add its node to this parent as a child
            name (str): The name with which this child should use when it adds itself to its parent

        Returns:
            bool: True if the given function successfully parsed its grammar element, False otherwise
        """
        saved = self.index
        node = function()
        if node is None:
            self.index = saved
            return False

        if name is None:
            name = node.name
        parent.addchild(name, node)
        return True

    def import_declaration(self):
        """
        An import declaration is defined as follows

        **ImportDeclaration**  ::=  'import' TypeName ';'

        Creates a node containing a single child:
            * Name - An ASTNode representing a TypeName

        Returns:
            ASTNode: The node generated by parsing the import declaration, or None if parsing failed
        """
        if not self.match('import'):
            return None
        node = ASTNode('ImportDeclaration')
        if not self.parse(self.type_name, node, 'Name'):
            raise CompilerException(CompilerException.SYNTAX, 'Expected type name after import keyword',
                                    self.value(-1))
        if not self.match(';'):
            raise CompilerException(CompilerException.SYNTAX, "Expected ';' after import declaration",
                                    self.value(-1))
        return node

    def class_declaration(self):
        """
        Parses a class declaration. A class declaration is defined as follows:

        **ClassDeclaration**  ::=  PrivacyModifier? 'class' Identifier ClassBody

        **PrivacyModifier**   ::=  'private' | 'public'

        **ClassBody**         ::=  '{' (FieldDeclaration | MethodDeclaration | Constructor)* '}'

        A class declaration has 5 children:
            * PrivacyModifier - A CodeObject that is one of 'private', 'public' or None
            * Name - CodeObject that is a string containing the name of the class
            * FieldDeclarations - List of ASTNodes
            * MethodDeclarations - List of ASTNodes
            * Constructors - List of ASTNodes

        Returns:
            ASTNode: The node generated by parsing the class declaration, or None if parsing failed
        """
        node = ASTNode('ClassDeclaration')
        if self.match('private') or self.match('public'):
            node.addchild('PrivacyModifier', self.value(-1))
        else:
            node.addchild('PrivacyModifier', None)
        if not self.match('class'):
            return None

        if not self.type() == Token.identifier:
            raise CompilerException(CompilerException.SYNTAX,
                                    "Expected class name after the 'class' keyword", self.value(-1))
        node.addchild('Name', self.value())
        self.index += 1
        if not self.match('{'):
            raise CompilerException(CompilerException.SYNTAX, "Expected opening brace, '{', after a class declaration",
                                    self.value(-1))

        while self.parse(self.field_declaration, node, 'Fields') or \
                self.parse(self.method_declaration, node, 'Methods') or \
                self.parse(self.constructor_definition, node, 'constructors'):
            pass

        if not self.match('}'):
            self.raise_error(CompilerException.SYNTAX,
                             "Unexpected token in class body", missing_msg="Expected closing brace, '}', after a class"
                                                                           "body")

        return node

    def field_declaration(self):
        return None

    def method_declaration(self):
        return None

    def constructor_definition(self):
        return None

    def type_name(self):
        """
        Parses a type name. A type name is a sequence of identifiers, seperated with dots:
        TypeName        ::=  (Identifier '.')* Identifier

        Creates a node with a single child:
            - Names - List of CodeObjects where each one is an identifier in the sequence of names

        Returns:
            ASTNode: The node generated by parsing the type name, or None if parsing failed
        """
        if self.type() is not Token.identifier:
            return None

        node = ASTNode('TypeName', {'Names': [self.value()]})
        self.index += 1
        while self.match('.'):
            if self.type() is Token.identifier:
                node.addchild('Names', self.value())
                self.index += 1
            else:
                raise CompilerException(CompilerException.SYNTAX,
                                        'Missing identifier after dot in type name', self.value(-1))

        return node


class ASTNode:
    """
    Represents a single node in an abstract syntax tree. Each node has a name (e.g. class declaration) and a dictionary
    of its children. Each child is an ASTNode. The keys of the children dictionary are the names of each child node,
    and the values are can be one of three things:

    - A token generated in the tokenizer. This is when the child is a terminal value (has no children of it own). A
      token is a tuple, consisting of the type (str) and the value (CodeObject)
    - An ASTNode. This is used when the child has its own children
    - A list of ASTNode objects or tokens. The list must consist of one or the other (not both). This is used when it is
      not known how many children of a certain type a node will have. For example, a parameter list will have an
      arbitrary number of ASTNode children, one for each parameter
    For example, a class declaraction node may have the following children:
        'privacy modifier', 'name', 'variable declarations', 'method declarations'
    where 'privacy modifier' and 'name' both consist of a token, and 'variable declarations',
    'method declarations' would both be lists of ASTNodes, since we cannot know how many variables/methods a class will
    have

    Attributes:
        name (str): the name/type of the ASTNode
        children (dict) dictionary containing all the children of the node
    """

    def __init__(self, name, children=None):
        self.name = name
        if children is None:
            self.children = {}
        else:
            self.children = children

    def addchild(self, name, child):
        """
        Adds the child to the children dictionary at the location given by name. If multiple children are added to the
        same name, then they will all be stored in a list. If a given item must be a list, even if it may have zero or
        one elements, then add an emtpy list before adding any children under that name
        """
        if name in self.children:
            if type(self[name]) == list:
                self[name].append(child)
            else:
                self[name] = [self[name], child]
        else:
            self[name] = child

    def __setitem__(self, name, child):
        """
        Sets the child with the given name to the given value.
        Note: This will overwrite any child already existing under that name. To add a child without the risk of
        overwriting a child use addchild(name, child)
        """
        self.children[name] = child

    def __getitem__(self, item):
        """This is used to access the children of the ASTNode"""
        return self.children[item]

    def print_tree(self, depth=0):
        """
        Prints this node, along will all child nodes, in a heirarcical manner
        Args:
            depth: This is the depth of this node from the root of the tree. This determines how far to indent this
                node
        """
        if depth == 0:
            print(self.name)
        prefix = '|   ' * depth + '|-> '
        for name, child in self.children.items():
            print(prefix + name)
            if type(child) is list:
                for item in child:
                    if type(item) is ASTNode:
                        item.print_tree(depth + 1)
                    else:
                        print('|   ' + prefix + str(item))
            elif type(child) is ASTNode:
                child.print_tree(depth + 1)
            else:
                print('|   ' + prefix + str(child))
